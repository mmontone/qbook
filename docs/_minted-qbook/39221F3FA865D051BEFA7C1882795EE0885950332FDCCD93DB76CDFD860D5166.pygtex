\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{defmethod} \PYG{n+nv}{process\PYGZhy{}directive} \PYG{p}{((}\PYG{n+nv}{part} \PYG{n+nv}{comment\PYGZhy{}part}\PYG{p}{))}
  \PYG{p}{(}\PYG{k}{declare} \PYG{p}{(}\PYG{k}{special} \PYG{n+nv+vg}{*source\PYGZhy{}file*}\PYG{p}{))}
  \PYG{p}{(}\PYG{n+nb}{multiple\PYGZhy{}value\PYGZhy{}bind} \PYG{p}{(}\PYG{n+nv}{matchp} \PYG{n+nv}{strings}\PYG{p}{)}
      \PYG{p}{(}\PYG{n+nv}{cl\PYGZhy{}ppcre:scan\PYGZhy{}to\PYGZhy{}strings} \PYG{p}{(}\PYG{k}{load\PYGZhy{}time\PYGZhy{}value} \PYG{p}{(}\PYG{n+nv}{cl\PYGZhy{}ppcre:create\PYGZhy{}scanner} \PYG{l+s}{\PYGZdq{}\PYGZca{}@include (.*)\PYGZdq{}}\PYG{p}{))}
                                \PYG{p}{(}\PYG{n+nv}{text} \PYG{n+nv}{part}\PYG{p}{))}
    \PYG{p}{(}\PYG{k}{if} \PYG{n+nv}{matchp}
        \PYG{p}{(}\PYG{k}{return\PYGZhy{}from} \PYG{n+nv}{process\PYGZhy{}directive} \PYG{p}{(}\PYG{n+nv}{read\PYGZhy{}source\PYGZhy{}file}
                                        \PYG{p}{(}\PYG{n+nb}{merge\PYGZhy{}pathnames} \PYG{p}{(}\PYG{k}{let} \PYG{p}{((}\PYG{n+nv+vg}{*readtable*} \PYG{p}{(}\PYG{n+nb}{copy\PYGZhy{}readtable} \PYG{n+no}{nil}\PYG{p}{)))}
                                                           \PYG{p}{(}\PYG{n+nb}{read\PYGZhy{}from\PYGZhy{}string} \PYG{p}{(}\PYG{n+nb}{aref} \PYG{n+nv}{strings} \PYG{l+m+mi}{0}\PYG{p}{)))}
                                                         \PYG{p}{(}\PYG{n+nb}{truename} \PYG{n+nv+vg}{*source\PYGZhy{}file*}\PYG{p}{))))}
        \PYG{p}{(}\PYG{k}{return\PYGZhy{}from} \PYG{n+nv}{process\PYGZhy{}directive} \PYG{p}{(}\PYG{n+nb}{list} \PYG{n+nv}{part}\PYG{p}{)))))}
\end{Verbatim}
